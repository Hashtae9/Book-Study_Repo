# Docker

## 1. 알아두어야 할 시스템, 인프라 지식

### 인프라

+ 어플리케이션 동작에 필요한 하드웨어와 OS 및 미들웨어 등을 의미



#### 기능요건

+ 필요한 시스템 기능을 정의한 것
+ 시스템과 소프트웨어에서 무엇이 가능한지를 정리하여 프로그래밍으로 해결



#### 비기능요건

+ 시스템 성능과 신뢰성, 확장성, 운영성, 보안 등과 관련된 요건
+ 기능 요건 이외의 모든 것



#### 하드웨어

+ 인프라를 구성하는 물리적 요소
+ 서버 본체와 데이터를 저장하기 위한 스토리지 및 전원장치
+ 데이터센터 설비(건물, 공조, 보안장치, 소방설비 등)



#### 네트워크

+ 시스템 사용자가 원격지에서 서버로 액세스 할 수 있도록 연결하는 요소
+ 라우터, 스위치, 방화벽 등 네트워크 기기와 이를 접속하기 위한 케이블 배선 등
+ VPN, 스팸 필터, 침입 탐지 시스템(IDS) 등의 보안 기기도 포함



#### OS

+ 하드웨어와 네트워크 기기를 제어하기위한 기본 소프트웨어
+ 하드웨어 리소스와 프로세스를 관리
+ 클라이언트 OS (Windows, Android, Mac OS) - GUI 기능과 멀티미디어 기능 탑재
+ 서버 OS(Window Server, Unix 서버, Linux 서버) - 하드웨어 성능을 끌어내기 위해 장시간 구동해도 문제x, 대량 처리 효율적



#### 미들웨어

+ 서버 OS에서 서버가 특정 역할을 수행할 수 있도록 동작하는 소프트웨어
+ 상용 소프트웨어와 오픈소스로 나뉘어짐



### 인프라 종류

#### 온프레미스

+ 시스템 구축에서 부터 운영까지 자사에 데이터 센터를 두고 수행하는 형태
+ 서버와 네트워크 기기를 자사에서 조달하여, 시스템 요건에 맞는 인프라를 구축한뒤 자사에서 직접 운영



#### 퍼블릭 클라우드

+ 인터넷을 통해 불특정 다수에게 제공하는 클라우드 서비스
+ 자사에 데이터 센터를 두지 않기 때문에 초기 인프라 관련 비용 필요 x
+ IaaS, PaaS, SaaS 등으로 나뉨
  + IaaS는 사용하고자하는 스펙의 가상 서버와 스토리지를 선택하여 사용한 시간과 데이터 양에 따라 요금을 지불



#### 프라이빗 클라우드

+ 특정 기업 그룹에만 제공하는 클라우드



### 클라우드에 적합한 케이스

1. 트래픽 변화가 많은 시스템
   + 사이징 : 트래픽 양에 따라 서버 스펙과 네트워크를 예측하여 설계하는 것
   + 시스템을 사이징 하기 어려운 경우 클라우드에서 구성하는 것이 유리
     + 클라우드의 오토 스케일 기능
       + 시스템 부하에 따라 유동적으로 서버 스펙이나 스토리지 용량을 증설할 수 있음
2. 재해에 대비하기 위해 해외에 백업을 구축하고자 하는 시스템
3. 되도록 빨리 동작해야 하는 시스템



### 온프레미스에 적합한 케이스

1. 높은 가용성이 요구되는 시스템
   + 운영 서버의 네트워크가 끊기면 안되는 경우 등 클라우드 벤더가 보장하는 범위 이상의 가용성이 필요한 경우
2. 높은 기밀성이 요구되는 데이터를 다루는 시스템
3. 특수 요건의 시스템
   + 일반적이지 않은 디스크나 특수한 플랫폼에서만 동작하는 시스템을 구축해 마이그레이션 해야하는 경우
4. 총 비용이 높은 시스템



### 방화벽

+ 내부 네트워크와 외부와의 통신을 제어하고 내부 네트워크를 안전하기 지키기 위한 기술



#### 패킷 필터링 방식(ACL - Access Control List(패킷 필터 룰))

+ 통신하는 패킷을 포트번호와 IP Address 기반으로 필터링하는 방법
  + ex) 80(http), 443(https)만 열기
  + 안전한 세그먼트에서 온 패킷 이외에는 모두 차단하는 특별한 룰 정하기
  + OSI 7 Layer의 Network 계층, Transport 계층에서 동작



#### 애플리케이션 게이트웨이 방식

+ 애플리케이션 프로토콜 레벨에서 외부와 통신하며 제어하는 방법
+ 일반적으로 프록시 서버라 부름



### 라우터와 L3 스위치

#### 라우터

+ 서로 다른 네트워크를 연결하기 위한 통신 장비
+ Network 계층에서 동작, 어떤 루트로 데이터를 전송할지 판단하기 위한 경로 선택 기능을 가지고 있음
  + 정적 경로(Static Route) : 라우터에 설정된 라우팅 테이블 기반 경로 선택
  + 동적 경로(Dynamic Route) : 라우팅 프로토콜에서 설정한 경로
+ L3 스위치는 라우팅을 하드웨어에서 처리하기 때문에 빠르게 동작





### 서버

#### CPU 

+ 프로그램 연산과 처리등을 수행하는 전자회로 부품
+ CPU 주파수가 크면 클수록 높은 연산 기능
+ CPU 주요 연산 회로 = Core (코어수가 크면 동시 처리 연산 수가 증가)
+ CPU의 빠른 처리를 위해 메모리와의 처리 속도 차를 줄이기 위한 동적 캐시를 사용



#### 메모리

+ CPU가 직접 액세스할 수 있는 기억장치
+ 서버용으로는 저전력에 에러처리 기능을 가진 모델이 주로 채택



#### 스토리지

+ 데이터베이스의 데이터를 저장하는 디바이스
+ 대량 데이터 처리를 하는 경우가 많아 스토리지 용량과 read 및 write 속도가 시스템 전체 응답속도에 영향
+ 하드디스크, SSD 등등
+ 장애발생 시 데이터가 분실될 수 있기 때문에 RAID 구성을 함
  + RAID : 종류별로 다르지만 보통 한 데이터를 2개 이상의 하드디스크에 분산시켜 저장(스트라이핑)



### OS(Linux) 기초 지식 

+ 하드웨어와 네트워크를 제어하는 역할
  + UNIX, LINUX, Window Server....



#### Linux 서버

##### 	Linux 커널

+ 메모리 관리, 파일 시스템, 프로세스 관리, 디바이스 제어 등 하드웨어와 애플리케이션 소프트웨어를 제어하기 위한 기본적인 기능을 가진 소프트웨어
+ 하드웨어 제어 담당 OS의 코어 기능(C언어와 어셈블리어 코드로 구성)
  + 디바이스 관리
    + Linux 커널은 하드웨어(CPU, 메모리, 디스크, 입출력 디바이스 등)을 디바이스 드라이버 SW로 제어
  + 프로세스 관리
    + Linux에서 명령을 실행할 때 프로그램 파일에 저장된 내용을 읽어들여 메모리에 뿌린 뒤에 실행
    + 이렇게 실행된 프로그램을 프로세스라 함
    + 각 프로세스 별 PID(프로세스ID)라는 식별자를 붙여 관리하며 이를 통해 프로세스 실행에 필요한 CPU를 적절하게 할당
  + 메모리 관리
    + 프로세스가 동작하면 메모리 상의 프로그램과 함께 프로그램이 사용하는 데이터도 실행
    + Linux커널은 프로그램 및 데이터를 물리 메모리에 적절하게 분배하는 기능
    + 실행이 끝난 프로세스의 메모리 영역을 반납
    + 메모리에는 용량제한존재 => 물리적 용량이 넘어선 프로그램이나 데이터가 진행되면 하드디스크와 같은 보조기억장치의 가상 메모리 영역 사용(스와프)
+ 리눅스 커널을 조작하기위해 Shell을 사용(커맨드 입력하고 이를 커널에 전달)



##### 	Linux 배포판

+ Linux는 패키지를 만들어 배포하는데 이 배포판에 Linux 커널과 각종 커맨드, 라이브러리, 애플리케이션이 포함
  + Linux 커널 이외의 영역을 userland(사용자 진영)
  + userland에서는 디바이스에 직접 액세스 할 수 없기에 Linux 커널을 통해 처리만 가능
+ 주요 리눅스 배포판으로는 Debian, Red Hat...



##### 	Linux 파일 시스템

+ 리눅스에서 하드디스크와 USB 메모리, CD, DVD등 데이터에 액세스하기 위한 시스템
+ VFS(Virtual File System : 가상 파일 시스템)이라는 시스템을 사용해 데이터에 편리하게 액세스



##### 	Linux 보안 기능

+ UNIX 및 Linux는 강력한 보안 기능을 가진 OS로서 서버용으로 널리 사용 





### 미들웨어

+ OS와 업무 처리를 수행하는 애플리케이션의 사이에 있는 소프트웨어
+ OS가 가진 기능을 확장한 것



#### 웹 서버 및 웹 애플리케이션 서버

+ 클라이언트 브라우저에서 HTTP  request를 받아 웹 컨텐츠(HTML, CSS 등)을 response하거나 다른 프로그램을 호출하는 등의 기능을 가진 서버
+ Apache HTTP Server, nginx...






# 컨테이너 가상화 기술과 Docker

## 가상화 기술

### 가상 환경

+ 별도의 물리적인 하드웨어 대신 가상 OS 위에 애플리케이션을 구등시키는 것
+ 기본이 되는 하드웨어에 OS(호스트 OS)를 설치파고 그 위에 가상화 소프트웨어를 올린 뒤 게스트 OS를 구동
+ 가상화 소프트웨어를 사용하면 한대의 하드웨어에 여러 OS를 가상으로 구동시기거나 파기 가능
  + 예시<img src="https://user-images.githubusercontent.com/101400894/221345857-3efff17f-a9d1-4908-ad59-f820b98b6a23.png" alt="image" style="zoom:80%;" ALIGN="LEFT"/>









#### 호스트 가상화

+ 하드웨어 위에 베이스가 되는 호스트 OS를 설치하고 그 위에 가상화 소프트웨어를 설치한 뒤 게스트 OS를 구동하는 기술
+ 호스트 OS 상에서 게스트 OS가 동작하기 때문에 오버헤드가 큼
  + 오버헤드 : 가상화를 위해 필요한 추가 CPU 리소스, 디스크 용량, 메모리 사용량 등



#### 하이퍼바이저 가상화

<img src="https://user-images.githubusercontent.com/101400894/221346825-696bdace-dbdf-4cdd-bc6c-a08b5c9e040e.png" alt="image" style="zoom:100%;" ALIGN="LEFT"/>

+ 하드웨어 위에 가상화 전문 소프트웨어인 하이퍼바이저를 설치 후 하드웨어와 가상환경을 제어



#### 컨테이너 가상화

+ 호스트 OS 상에서 논리적으로 구역(컨테이너)를 나눠 애플리케이션 동작을 위한 라이브러리와 애플리케이션 등을 컨테이너 안에 넣고 개별 서버처럼 사용하는 것
+ 오버헤드가 적어 가볍고 빠름



## Docker의 특징

+ 컨테이너 가상화 환경에서 애플리케이션을 관리하고 실행하기 위한 오픈소스 플랫폼
+ Linux위에서 동작



### 이식성

+ 한번 만들어 두면 어디에서든 동작하는 소프트웨어의 특성
+ 시스템 개발 시, 운영 환경에서 업무 애플리케이션을 구동하기 위해서 아래의 요소가 필수
  + 업무 애플리케이션 실행 모듈(프로그램  본체)
  + 미들웨어와 라이브러리
  + OS 및 네트워크 등 인프라 환경 설정
+ 즉 , 개발환경과 테스트 환경과 운영환경의 하드웨어, OS, 미들웨어가 다르기 때문에 인프라가 다르면 동작하지 않을 수 있음
+ Docker에서는 인프라 환경을 컨테이너로 관리
+ 애플리케이션 실행에 필수적인 모든 파일 및 디렉터리를 통째로 컨테이너에 담는 것



### 상호운용성

+ 여러 조직이나 시스템과 연계하여 사용할 수 있는 소프트웨어의 특성



## Docker 기본 기능

+ Docker 이미지 생성
+ Docker 컨테이너 생성
+ Docker 이미지 공개 및 공유



### Docker 이미지 생성

+ Docker 이미지
  + Docker는 애플리케이션 실행에 필요한 프로그램, 라이브러리, 미들웨어와 OS, 네트워크 설정 등이 담긴 디렉터리
  + 실행 환경에서 동작하는 컨테이너의 기반
  + 이미지를 tar 파일로 만들 수도 있음



### Docker 컨테이너 동작

+ Docker는 리눅스 상에서 컨테이너 단위로 서버 구동
+ Docker 이미지를 통해 컨테이너 구동



### Docker 이미지 공개 및 공유



## Docker의 동작 구조

**Docker는 리눅스상에서 동작하는 가상화 기술을 기반**



### 컨테이너를 구분하는 구조(namespace)

+ Docker는 컨테이너라는 독립된 환경을 만들고 이를 나누어 애플리케이션 실행 환경을 만듬
+ 컨테이너를 나눌때 리눅스 커널의 namespace 기능 사용
+ 한데 합쳐진 데이터에 이름을 부텨 충돌가능성을 낮추고 쉽게 참조할수 있도록 함



#### PID namespace

+ Linux에서 각 프로세스에 할당된 고유한 ID

#### Network namespace

+ 네트워크 디바이스, IP Address, 포트번호, 라우팅 테이블, 필터링 테이블 등 네트워크 리소스를 namespace 별로 할당
+ 호스트 OS 위에서 사용중인 포트가 있어도 컨테이너 안에서 같은 번호의 포트를 사용할 수 있음

#### UID namespace

+ UID(user ID), GID(Group ID)를 namespace별로 독립하여 가질 수 있음
+ namespace내에서 UID, GID가 0인 root 사용자를 호스트 OS상에서는 일반 사용자로 인식할 수 있음
  + namespace의 관리자 계정이 호스트OS에서는 관리 권한을 가질 수 없게 할 수 있음
  + 보안 강화

#### MOUNT namespace

+ 리눅스에서 파일 시스템을 사용하기 위해서는 마운트가 필요
  + 마운트 : 컴퓨트에 접속한 기기와 기억장치를 OS에 인식시키는 것
+ 마운트를 조작하여 namespace 내에 파일 시스템 트리를 만듦

#### UTS namespace

+ namespace별로 호스트명과 도메인명을 독자적으로 가짐

#### IPC namespace

+ 프로세스 간 통신(IPC) 오브젝트를 namespace별로 가짐
  + IPC는 공유메모리와 세마포어 및 메시지 큐의 System V 프로세스 간 통신 오브젝트
  + 세마포어 : 프로세스에 필요한 자원관리에 이용되는 배타제어 방식
  + 메시지 큐 : 여러 프로세스 사이에서 비동기 통신이 이뤄질 때 사용하는 큐잉방식



### 리소스 관리 구조(cgroup)

**여러 컨테이너에서 물리머신의 리소스를 공유하여 사용**

+ 리눅스는 프로그램을 프로세스로 실행
+ cgroup은 프로세스 및 쓰레드를 그룹화하여 이를 관리



### 네트워크 구성(가상 bridge 및 가상 NIC)

+ Docker의 컨테이너는 서버의 물리 NIC와 별도로 각 컨테이너 마다 가상 NIC가 할당되어 있음
+ 이러한 가상 NIC는 docker0라는 가상 bridge에 접속하여 컨테이너끼리 통신



#### Docker 컨테이너 간의 통신

+ 동일한 호스트상의 Docker 컨테이너는 구동시 private Address가 자동으로 할당
+ 컨테이너 끼리 통신하기 위해 '링크 기능' 활용



#### Docker 컨테이너와 외부 네트워크 통신

+ 가상 bridge docker0와 호스트 OS의 물리 NIC에서 패킷을 전송
+ NAPT 기능 사용(Network Address Port Translation)
  + 하나의 IP Address를 여러 컴퓨터에서 공유하는 기술
  + IP Address 와 포트번호를 변환하는 기능
  + Private IP Address와 Global IP Address를 상호변환, TCP&UDP 포트번호까지 동적으로 변환
  + 여러 머신에서 한 Global IP Address로 접속 가능
  + **NAT는 주소만 변경하지만 NATP는 포트까지 변경**

